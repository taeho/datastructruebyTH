원형 연결리스트(1)	http://blog.naver.com/akstn3110/220502494131

> 원형 연결 리스트
 - 단순 연결 리스트에서 마지막 노드가 리스트의 첫 번째 노드를 가리키게 하여 리스트의 구조를 원형으로
 만든 연결리스트를 원형 연결 리스트(Circular Linked List)라고 한다. 원형 연결 리스트는
 단순 연결 리스트의 마지막 노드의 링크 필드에 첫 번째 노드에 대한 참조값을 저장하여 구성한다.
 
 - 단순 연결 리스트는 시작 노드에서 링크를 따라 이동하여 마지막 노드까지 순회할 수 있는데,
 현재 노드에서 이전 노드를 접근 하려면 현재 위치에 상관없이 항상 리스트의 첫 번째 부터 다시 시작해야 한다.
 그러나 마지막 노드와 첫 번째 노드가 연결된 원형 연결 리스트에서는 링크를 따라 계속 순회하면 이전 노드에
 접근할 수 있다.
 
 1. 원형 연결 리스트의 삽입 연산
 - 원형 연결 리스트에서의 삽입 연산은 마지막 노드의 링크를 첫 번째 노드로 연결하는 부분만 제외하고는
 단순 연결 리스트에서의 연산과 같다. 원형 연결 리스트에서는 리스트의 마지막에 노드를 삽입하는 것이
 곧 리스트의 첫 번째 노드를 삽입하는 것과 같은 의미이다.
  따라서 원형 연결 리스트에서 노드를 삽입하는 경우는 노드의 첫 번째 노드를 삽입하는 경우와 중간 노드로
  삽입하는 경우로 나눌 수 있다.

* 첫 번째 노드로 삽입하기
 - 원형 연결 리스트 CL에 x값을 갖는 노드 new를 삽입하는 알고리즘은 다음과 같다.
 
<원형 연결 리스트의 첫 번째 노드 삽입 알고리즘>
insertFrontNode(CL, x)
	new <- newNode();
	new.data <- x;
	if(CL = null) then {			// (1)
		CL <- new;					// (2)
		new.link <- new;			// (3)
	}
	else {							// (4)
		temp <- CL;					// (5)
		while(temp.link != CL) do	// (6)
			temp <- temp.link;
		new.link <- temp.link;		// (7)
		temp.link <- new;			// (8)
		CL <- new;					// (9)
	}
end insertFrontNode()
--------------------------
 원형 연결 리스트에서 첫 번째 노드 삽입 알고리즘은 단순 연결 리스트에서의 첫 번째 노드 삽입 알고리즘과
 마지막 노드 삽입 알고리즘을 혼합한 형태가 된다.

 (1) 공백 리스트인 경우에는 삽입하는 노드 new가 리스트의 첫 번째 노드이자 마지막 노드이다.
 (2) 원형 연결 리스트의 시작 노드에 대한 참조값을 저장하는 참조변수 CL에 삽입할 새 노드에 대한
     참조값을 저장하여 CL이 노드 new를 첫 번째 노드로 가리키게 한다.
 (3) 참조변수 new의 값을 new가 가리키는 새 노드의 링크 필드(new.link)에 저장하여 노드 new가
    자기 자신을 가리키게 함으로써 노드 new를 원형 연결 리스트 CL의 첫 번째 노드이자 마지막 노드가 되도록
    저장한다.
 (4) 리스트 CL이 공백 리스트가 아닌 경우에는 단순 연결 리스트에서의 마지막 노드 삽입 연산 과정이 수행된다.
 (5) CL의 값, 즉 리스트의 CL의 첫 번째 노드에 대한 참조값을 임시 순회 참조변수 temp에 저장하여
   노드 순회의 시작 위치를 지정한다.
 (6) while문을 수행하여 temp를 링크를 따라 마지막 노드까지 이동시킨다.
 (7) temp가 가리키는 노드, 즉 리스트의 마지막 노드의 링크 값을 노드 new의 링크에 저장하여 노드new가
   노드temp의 다음 노드를 가리키게 한다. 리스트 CL은 원형 연결 리스트이므로 마지막 노드의 다음 노드는
   리스트의 첫 번째 노드가 된다. 따라서 노드 new가 리스트CL의 첫번째 노드를 가리키게 된다.
 (8) new의 값을 temp가 가리키고 잇는 마지막 노드의 링크에 저장하여 리스트의 마지막 노드가 노드new를
 가리키게 한다.
 (9) new의 값, 즉 새 노드에 대한 참조값을 CL에 저장하여 노드 new가 리스트의 첫 번째 노드가 되도록 저장한다.
     
 
 http://blog.naver.com/akstn3110/220502530900
 
 * 중간 노드로 삽입 하기
  다음은 원형 연결 리스트 CL에 x값을 갖는 노드 new를 pre가 가리키는 노드의 다음 노드로 삽입하는 알고리즘 이다.
  
  < 원형 연결 리스트의 중간 노드 삽입 알고리즘 >
 insertMiddleNode(CL, pre, x)
 	new <-getNode();
 	new.data <- x;
 	if(CL = null) then {		// (1)
 		CL <- new;
 		new.link <- new;
 	}
 	else {						// (2)
 		new.link <- pre.link;	// (3)
 		pre.link <- new;		// (4)
 	}
 end insertMiddleNode()
 
 (1) 노드 new를 삽일할 원형 연결 리스트 CL이 공백 리스트인 경우에 중간 노드로 
   삽입하는 방법은 공백 리스트인 경우에 첫 번째 노드로 삽입하는 방법과 같다.
   
 (2) 리스트가 공백이 아닌 경우에는 pre가 가리키는 노드 뒤에 노드 new를 삽입한다.
 
 (3) 노드 pre의 다음 노드로 노드 new 를 삽입하기 위해 먼저 노드 pre의 다음 노드를
   new 의 다음 노드로 연결한다.
   
 (4) new의 값을 노드 pre의 링크에 저장하여, 노드 new를 노드 pre의 다음 노드로 연결한다.
 
 
 
* 원형 연결 리스트의 원소 삭제
 원형 연결 리스트에서 노드를 삭제하는 알고리즘이 다음과 같다. 원형 연결 리스트 CL에서 pre가
 가리키는 노드의 다음 노드를 삭제하고, 삭제한 노드는 자유 공간 리스트에 반환 한다. 
 old는 삭제할 노드를 지정한다.
 
< 원형 연결 리스트의 노드 삭제 알고리즘 >
deleteNode(CL, pre)
	if(CL = null) then error;
	else {
		old <- pre.link;		// (1)
		pre.link <- old.link;	// (2)
		if(old = CL) then		// (3)
			CL <- old.link;		// (4)
		returnNode(old);		// (5)
	}
end deleteNode()

(1) 노드 pre의 다음 노드를 삭제할 노드 old로 지정한다.

(2) 삭제할 노드 old의 다음 노드를 노드 pre의 다음 노드로 지정한다.

(3) 삭제할 노드 old가 CL 이라면 삭제할 노드 old는 리스트 CL 의 첫번째 노드가 된다.
   노드 old 가 첫번째 노드일 경우에 (1) 과 (2)를 수행한 다음의 상태다.

(4) 첫 번째 노드를 삭제하는 경우에는 원형 연결 리스트의 연결이 끊어지지 않도록 하기위해서
  CL에 대한 연결 처리가 추가로 필요하다. 노드 old의 링크값을 리스트 참조변수 CL에 
  저장하여 두 번째 노드가 리스트의 첫 번째 노드가 되도록 조정한다.

(5) 리스트 CL에 대한 노드 삭제 연산이 완성되었으므로 삭제한 노드 old를 자유공간리스트에
  반환한다.

















 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 