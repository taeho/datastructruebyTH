http://blog.naver.com/akstn3110/220500516631
* 연결 자료구조 방식
 - 순차 연결 리스트는 논리적인 순서와 물리적인 순서가 같기 때문에 원소의 위치를 찾아 엑세스 하기 쉽다는
 장점이 있지만, 삽입 연산이나 삭제 연산 후에 연속적인 물리 주소를 유지하기 위해서 원소들을
 이동시키는 추가적인 작업과 시간이 필요하다.
   원소의 개수가 많고, 삽입 & 삭제 연산이 많이 발생하는 경우에는 원소들의 이동작업으로 인한
 오버헤드가 증가하여 성능상의 문제를 일으킬 수 있다. 또한 순차 자료구조 방식은 배열을 이용하여
 구현하기 때문에 배열이 갖고 있는 메모리의 사용의 비효율성 문제를 그대로 갖는다.
 
  순차 자료구조 방식에서 연산 시간에 대한 문제와 저장 공간에 대한 문제를 개선한 자료 표현방식으로
 연결 자료구조(Linked Data Structure) 방식 또는 
 비순차 자료구조 (Nonsequential Data Structure) 방식이 있다.
  연결 자료구조 방식에서는 순차 자료구조 방식에서처럼 원소의 논리적인 순서와 물리적인 순서가 일치할 필요가 없다.
 연속한 메모리 물리주소에 의해 원소의 순서를 표현하는 것이 아니라, 각 원소에 저장되어 있는
 다음 원소의 주소에 대한 참조에 의해서 연결되는 방식이기 때문에 물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않는다.
  하나의 순차 자료구조를 위해서는 하나의 고정크기 메모리 공간을 사용하지만, 연결 자료구조에서는
 여러 개의 작은 공간을 연결하여 전체를 표현하므로 크기 변경이 유연하고 좀 더 효율적으로 메모리를 사용할 수 있다.
 
 연결 리스트는 리스트를 연결 자료구조 방식으로 표현한 구조로서, 연결하는 방식에 따라 단순 연결 리스트와
원형 연결 리스트, 이중 연결 리스트, 이중 원형 연결 리스트로 나눌 수 있다.

* 연결 자료구조 방식에서 원소는 연결될 다음 원소의 주소를 저장해야 하기 때문에 <원소, 주소>의 단위로
저장해야 한다. 이러한 단위구조를 노드(node)라고 한다.

  노드는 아래와 같이 원소의 값을 저장하는 데이터 필드(Data Field)와 다음 노드의 주소를 저장하는
 링크 필드(Link Field)로 구성된다. 데이터 필드는 저장할 원소의 형태에 따라서 하나 이상의 필드로
 구성하기도 한다. 링크 필드는 메모리 참조 변수를 사용하여 주소에 대한 참조값을 저장하며, 링크 또한
 참조라고 한다.
 
 <원소, 주소>
[data|link] -> [data|link] -> [data|link] 
 


http://blog.naver.com/akstn3110/220501555387
단순 연결 리스트에서 노드를 삽입할 때와 삭제할 때 그리고 탐색할 때 사용하는 알고리즘에 대해 알아보자.

1. 삽입 알고리즘.
연결 리스트에서 노드를 삽입하는 경우는 리스트의 첫 번째 노드로 삽입하는 경우와
중간 노드로 삽입하는 경우, 그리고 마지막 노드로 삽입하는 경우가 있다.

[1] 첫번째 노드로 삽입하기
- 리스트 L의 첫 번째 노드로 데이터 필드 값이 x인 노드를 사입하는 연산에 대해
알고리즘 insertFirstNode()를 다음과 같이 정의할 수 있다.

<리스트의 첫 번째 노드 삽입 알고리즘>
insertFirstNode(L, x)
  new <- getNode();		//(1)
  new.data <- x;		//(2)
  new.link <- L;		//(3)
  L <- new;				//(4)
 end insertFirstNode()
 --------------------------
 (1) 삽입할 노드를 자유 공간 리스트에서 할당 받는다.
 (2) 새 노드의 데이터 필드에 x를 저장한다.
 (3) 리스트 L의 첫 번째 노드에 대한 참조값을 삽입할 새 노드 new의 링크 필드에 저장함으로써
     새 노드 new를 리스트의 L의 첫 번째 노드와 연결한다.
 (4) 참조변수 L에 새로운 노드 new에 대한 참조값을 저장하여 L이 새노드 new 를
    첫 번째 노드로 가리키도록 지정한다.
    
[2] 중간 노드로 삽입하기
- 리스트 L의 중간에 노드를 삽입하기 위해서는 삽입할 위치의 앞에 있는 선행자 노드를 알려주는
참조변수 pre가 필요하다. 다음의 알고리즘은 리스트 L에서 참조변수 pre가 가리키고 있는
노드의 뒤에 데이터 필드 값이 x인 새 노드를 삽입하는 알고리즘 이다.

<리스트의 중간 노드 삽입 알고리즘>
insertMiddleNode(L, pre, x)
  new <- getNode();
  new.data <- x;
  if(L = null) then {		//1
  	L <- new;				//(1-1)
  	new.link <- null;		//(1-2)
  }
  else {					// 2
  	new.link <- pre.link;	//(2-1)
  	pre.link <- new;		//(2-2)
  }
end insertMiddleNode()
--------------------------
1. 리스트 L이 공백 리스트인 겅우, 수행할 연산.
 (1) 참조변수 L에 새 노드에 대한 참조값을 저장하여 새 노드 new가 리스트 L의 첫 번째 노드가
      되도록 한다.
 (2) 공백리스트 L에 새 노드를 삽입하였으므로 새 노드 new는 리스트 L의 마지막 노드가 된다.
    따라서 새 노드 new의 링크필드(new.link)에 null을 저장하여 마지막 노드임을 표시한다.

2. 리스트 L이 공백 리스트가 아닌 경우, 수행할 연산.
 (1) 참조변수 pre는 삽입할 위치의 앞 노드를 가리킨다. 따라서 pre가 가리키는 노드의 다음 노드로
   새노드 new를 연결해야 하므로 노드 pre의 링크 필드값(pre.link)을 노드 new의 링크 필드에 저장하여,
   새노드 new가 노드 pre의 다음 노드를 가리키게 한다.
 (2) new의 값을 노드 pre의 링크 필드 (pre.link)에 저장하여 pre가 가리키는 노드의 다음노드로서
  새노드 new를 연결한다.

[3] 마지막 노드로 삽입하기
 - 새 노드 new를 마지막 노드로 삽입하기 위해서는 먼저 리스트의 마지막 노드를 찾아야 하는데,
  마지막 노드는 링크 필드가 null이다. 마지막 노드를 찾기 위해 링크 필드를 따라서 리스트의 노드들을 순회하는
  임시 참조 변수 temp를 사용한다. 다음은 새 노드 new를 마지막 노드로 삽입하는 알고리즘 이다.
 
 < 리스트의 마지막 노드 삽입 알고리즘 >
 insertLastNode(L, x)
   new <- getNode();
   new.data <- x;
   new.link <- null;
   if( L = null ) then {  // (1)
       L <- new;
       return;
   }
   temp <- L;			// (2)
   while(temp.link != null) do	// (3)
   	temp <- temp.link;	// (4)
   temp.link <- new;
 end insertLastNode()
 
 (1) 리스트 L이 공백 리스트인 경우에 마지막 노드의 삽입 연산은 앞에서 본 알고리즘과 같다.
  삽입하는 새 노드 new는 리스트의 L의 첫번째 노드이자 마지막 노드가 된다.
  
 (2) 리스트 L이 공백이 아닌 경우에는 마지막 노드 삽입 연산과정이 수행된다.
  마지막 노드로 삽입하기 위해서는 리스트 L의 현재 마지막 노드를 먼저 찾아야 한다.
  노드의 링크 필드를 따라서 노드들을 순회할 임시 참조변수 temp에 리스트의 첫 번째 노드 주소를 지정한다.
 
 (3) while 반복문을 수행하는 동안 temp가 노드의 링크필드(temp.link)에 삽입할 새 노드 new의
  참조값을 저장하여 리스트 L의 마지막 노드 뒤에 새 노드 new를 연결하게 한다.
  이제 new 노드가 리스트의 마지막 노드가 된다.
===============================================================================  
http://blog.naver.com/akstn3110/220501646361
-단순 연결 리스트의 알고리즘 - 삭제 알고리즘 & 탐색 알고리즘

2. 삭제 알고리즘
 - 리스트 L에서 pre가 가리키는 노드의 다음 노드를 삭제하는 알고리즘은 다음과 같다.
 old는 삭제할 노드를 알려주기 위해 사용한다.
 
<리스트의 노드 삭제 알고리즘>
deleteNode(L, pre)
	if( L = null) then error;		// (1)
	else{							// (2)
		old <- pre.link;			// (3)
		if(old = null ) then return;// (4)
		pre.link <- old.link;		// (5)	
	}
	returnNode(old);				// (6)
end deleteNode()

(1) 삭제 연산을 수행하려면 리스트에 노드가 하나 이상 있어야 한다.
 따라서 삭제 연산을 수행하기 전에 먼저 리스트 L이 공백 리스트인지 아닌지를 검사하여 공백리스트인 경우에는
 에러 처리하고, 삭제 연산 수행을 중단한다.

(2) 리스트 L이 공백리스트가 아닌 경우, 즉 삭제 연산을 수행할 수 있는 노드가 하나 이상 있는 경우에
 노드 삭제 연산을 수행한다.
 
(3) old 는 삭제할 노드를 지시해야 하므로 노드 pre의 링크 필드값 (pre.link).
 즉, 노드 pre의 다음 노드에 대한 참조값을 old에 저장하여 삭제할 노드를 가리키게 한다.
 
(4) 만약 노드 pre가 리스트의 마지막 노드였다면 pre.link 값은 null 이므로 (3)을 수행한 후의
 old값은 null이 된다. old값이 null이라는 것은 노드 pre뒤에 삭제할 노드가 없다는 의미이므로
 삭제연산을 더이상 수행하지 못한다.
 old의 값이 null이 아니고 삭제할 노드가 있는 경우에 삭제 연산을 수행하고 노드 old를 자유공간
 리스트에 반환한다.
 
(5) 삭제할 노드 old의 다음 노드를 노드 pre의 다음 노드로 연결한다.

(6) 삭제한 노드 old를 자유 공간 리스트에 반환한다.


===============================================================================
3. 노드 탐색 알고리즘 
- 연결리스트에서 원소값이 x인 노드를 탐색하려면 리스트의 노드를 처음부터 하나씩 순회하면서
노드의 데이터 필드값과 x를 비교하여 일치하는 노드를 찾아야 한다. 
탐색 연산에 대한 알고리즘은 다음과 같다.

<리스트 L에서 x노드 탐색 알고리즘>

searchNode(L, x)
	temp <- L;				// (1)
	while(temp != null) do{	// (2)
		if(temp.data != x) then return temp;
		temp <- temp.link;
	}
	return temp;			// (3)
end searchNode()
 
(1) 리스트 L의 시작 노드에 대한 참조값을 노드 탐색을 위해 사용할 순회 참조변수 temp에 저장하여
  temp의 시작위치를 지정한다.
 
(2) tmep가 null이 아닌 동안, 즉, temp가 가리키는 노드가 마지막 노드가 될때까지 노드 temp의
 데이터 필드값이 x인지 아닌지를 검사한다. 데이터 필드값이 x면 그 노드에 대한 참조값을 가진 temp를
 반환하고, x가 아니면 링크필드를 따라 다음 노드로 temp를 이동시킨다.

(3) while 반복문에서 x노드를 찾지 못하고 결국 리스트의 마지막 노드에서 while문 수행이 끝난
  상태이므로 temp의 값은 null이 되어 있다. 리스트 L에서 x 노드를 찾지 못한 경우에는 null 값을
  가진 temp를 반환한다.
  



























 	











   






















